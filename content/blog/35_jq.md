+++
author = "Noboru Saito"
title = "trdsql output"
date = "2022-06-02T07:00:00+09:00"
description = ""
tags = [
    "trdsql",
    "jq",
    "json",
]
categories = [
    "trdsql",
]
+++

これまでtdsqlが対象とするJSONはフラットなJSONでした。そのためSQLの対象となるのはトップレベルが配列になっている場合は、その中のオブジェクトが対象となります。

```example0.json
[
  {"age": "26", "name": "Tanaka"},
  {"age": "32", "name": "Suzuki"}
]
```

JSONは階層を深くすることができるので、さらに下の階層をSQLの対象としたい場合がありました。SQLの関数を使用して、アクセスすることも出来ますが、少し面倒でした。

```example0-s.json
{
  "list": [
    {"age": "26", "name": "Tanaka"},
    {"age": "32", "name": "Suzuki"}
  ]
}
```

tdsqlではJSONに対し、まず`jq`の構文を使用して処理し、その結果に対してSQLを実行できます。
`jq`の構文はファイル名の後に"::"を付け、その後に書きます。
`jq`の構文なので、主に"."ドットではじまり、中の値にアクセスします。

```console
trdsql "SELECT * FROM example0-s.json
```

（配列全体を１つの列と解釈してしまう）。

```csv
"[{""age"":""26"",""name"":""Tanaka""},{""age"":""32"",""name"":""Suzuki""}]"
```

```console
trdsql "SELECT * FROM example0-s.json::.list
```

（listをテーブルとして解釈して、中のオブジェクトを列として解釈する）。

```csv
26,Tanaka
32,Suzuki
```

深い階層にアクセスしたいときは、jqの構文では `.list.menu.item`のようにドットで繋いでいけば簡単にアクセスすることができます。
階層途中に配列があってもjqの構文（[]等が含まれる場合は「"」で括る等してください）が書ければアクセスすることができます。

```console
trdsql "SELECT * FROM example0-s.json::\".list[1].name\""
```

複雑な集計を`jq`で書くのは難しいため、対象をテーブル化することでSQLで集計するといったことができます。
また、`CSV`や他の形式に変換するのもtrdsqlでは簡単です。